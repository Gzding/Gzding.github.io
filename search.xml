<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/20/hello-world/"/>
      <url>/2024/03/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><span id="more"></span><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Learn Git</title>
      <link href="/2024/03/19/learn-git/"/>
      <url>/2024/03/19/learn-git/</url>
      
        <content type="html"><![CDATA[<h2 id="learngit"><a href="#learngit" class="headerlink" title="learngit"></a>learngit</h2><p>learn git </p><p>git clone <a href="mailto:&#103;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;">&#103;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;</a>:Gzding&#x2F;learngit.git</p><h2 id="SSH-密钥"><a href="#SSH-密钥" class="headerlink" title="SSH 密钥"></a>SSH 密钥</h2><p>要安装 OpenSSH 才能使用 ssh，这在 Windows 中默认安装了。</p><p>执行下面命令，生成 ssh 密钥【回答yes，其他全回车就行】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;your_email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>默认在用户目录下的 .ssh 目录内生成私钥和公钥 id_rsa.pub。</p><span id="more"></span><h2 id="本地-Git-环境配置"><a href="#本地-Git-环境配置" class="headerlink" title="本地 Git 环境配置"></a>本地 Git 环境配置</h2><h3 id="在Windows安装Git"><a href="#在Windows安装Git" class="headerlink" title="在Windows安装Git"></a>在Windows安装Git</h3><p>略（记得配置环境变量）</p><h3 id="设置-Git-参数"><a href="#设置-Git-参数" class="headerlink" title="设置 Git 参数"></a>设置 Git 参数</h3><p>在本地配置用户名和邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;name&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;email&quot;</span><br></code></pre></td></tr></table></figure><h2 id="克隆-GitHub-远程仓库"><a href="#克隆-GitHub-远程仓库" class="headerlink" title="克隆 GitHub 远程仓库"></a>克隆 GitHub 远程仓库</h2><blockquote><p>Github 的使用由于受到网络的阻碍，建议使用国内的 Gitee 更快！</p><p>但是，找项目还是 Github 中更丰富！</p></blockquote><h3 id="SSH-公钥"><a href="#SSH-公钥" class="headerlink" title="SSH 公钥"></a>SSH 公钥</h3><p>注册登录 GitHub，在我的设置中添加 ssh 公钥【就是[本地生成的公钥](#SSH 密钥)】。</p><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>在 GitHub 上 New 即可，设置仓库名和简介，并选择 Add a README file，以及 Add .gitignore文件，这样就创建好了远程仓库。 </p><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><blockquote><p>克隆仓库方法有：Https 形式、SSH 形式</p><p>其中，若要后续进行 push 等操作，最好使用 SSH 形式 clone；</p><p>这样，clone 之后，remote 信息中远程仓库的地址就是 SSH 形式的；</p><p>在后续 push 等操作时，就不用进行账号密码的验证操作了！</p></blockquote><p>在 GitHub 的仓库界面获得 clone 命令，在本地命令行中输入命令，克隆远程仓库。</p><p>然后就能正常使用此仓库了，其中本地和远程的 main 分支是关联的，且本地中记录了远程仓库的链接。</p><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>GitHub 取消了私有仓库的账号密钥的使用，需要使用 token 才能正常访问私有仓库，token 设置流程如下：</p><p>登录自己的 <a href="https://github.com/">GitHub</a> 账号，在个人头像那里的设置中生成 token，路径是 Settings&#x2F;Developer settings&#x2F;Personal access tokens，</p><ul><li>创建新的 token</li><li>设置 token name【这个就相当于账号名】</li><li>设置有效期</li><li>【重点】设置 token 权限，自己用就全选</li><li>生成即可</li><li>记得及时复制保存 token ，不然此页面一返回就看不到了</li></ul><h3 id="GitHub-Private-的使用"><a href="#GitHub-Private-的使用" class="headerlink" title="GitHub Private 的使用"></a>GitHub Private 的使用</h3><p>创建 private 仓库后，不能像 public 仓库那样任何人都随意克隆了，private 仓库克隆方法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://tokenName:token@github.com/githubAccount/repoName.git<br></code></pre></td></tr></table></figure><p>使用命令查看使用过 token 的仓库中token记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git remote -v<br></code></pre></td></tr></table></figure><p>会显示远程仓库的信息，其中就有 token 信息。</p><h2 id="Git-仓库管理"><a href="#Git-仓库管理" class="headerlink" title="Git 仓库管理"></a>Git 仓库管理</h2><h3 id="新建本地仓库"><a href="#新建本地仓库" class="headerlink" title="新建本地仓库"></a>新建本地仓库</h3><p>新建本地仓库方式有：</p><ul><li>克隆远程仓库：git clone git@ip:&#x2F;path&#x2F;test.git<ul><li>推荐使用这个，免得后续添加 remote 的操作了，而且可以使用 SSH 公钥免密直接 push 等操作！</li></ul></li><li>初始化本地文件夹为 git 仓库：git init</li></ul><p>新建仓库后添加的第一个文件建议为：.gitignore</p><ul><li>此文件中说明了此仓库不追踪哪些文件，也就是这些文件都会被忽略，</li><li>.gitignore 的内容可以在 GitHub 上创建新仓库时选择 .gitignore 类型，自动生成内容，复制一下来用就行。</li></ul><h3 id="Git-核心概念"><a href="#Git-核心概念" class="headerlink" title="Git 核心概念"></a><strong>Git 核心概念</strong></h3><p>git 仓库有两个区域，分别是 <strong>工作区</strong>、<strong>版本库</strong>；</p><p>工作区就是 .git 文件夹所在的整个文件夹，但不包括 .git 文件夹，也不包括 .gitignore 文件中声明的所有文件及文件夹；</p><ul><li>工作区中的文件可以说是当前 <a href="#%E4%BB%93%E5%BA%93%E7%89%88%E6%9C%AC%E7%BA%BF">HEAD(见下文)</a> 所在版本 ➕ 所有<strong>更新</strong>；</li></ul><p>版本库就是 .git 文件夹，其中分两部分：<strong>暂存区</strong>、<strong>分支区</strong>；</p><ul><li>暂存区：存储 git add 的所有更新，<ul><li>git commit 时，就会把暂存区中的内容<strong>提交</strong>到当前分支，形成一个新版本；</li></ul></li><li>分支区：存储所有分支的所有版本。</li></ul><h3 id="仓库版本线"><a href="#仓库版本线" class="headerlink" title="仓库版本线"></a>仓库版本线</h3><p><strong>版本生成</strong>：每次<strong>提交</strong>都会向仓库中添加一个版本，每个版本都有一个 id（一串十六进制数）；</p><p><strong>查看提交记录</strong>：使用记录查看命令 <code>git log</code> 或 <code>git log --pretty=oneline</code> 可以查看历史提交记录；</p><p><strong>HEAD</strong>：永远指向当前工作区所基于的版本，即：在工作区中未修改文件时，看到的所有内容都是 HEAD 所指向的版本的内容；</p><p><strong>版本线</strong>：每个版本都是基于 HEAD ➕ 一些更新，在提交后生成的；因此，这些版本可以串成一条线；</p><p><strong>分支</strong>：当然，有时候可以基于 HEAD 创建另外一条支线，形成<a href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86"><strong>分支</strong>(见下文)</a>；并且，分支在后面还能合并；如下图：</p><img src="/img/image-20240318163913152.png" alt="image-20240318163913152" style="zoom: 50%;" /><p><strong>查看</strong>：以版本线形式查看版本记录，<code>git log --graph</code> </p><h3 id="更新暂存提交"><a href="#更新暂存提交" class="headerlink" title="更新暂存提交"></a>更新暂存提交</h3><p><strong>更新</strong>：在仓库中，新建文件、修改文件、删除文件、重命名等都会对仓库的工作区产生<strong>更新</strong>（每个更新都是一个与 HEAD 所在版本的 diff）；</p><p><strong>查看</strong>：可以使用命令 <code>git status</code> 查看当前仓库的状态；可以使用命令 <code>git log</code> 查看历史提交记录；</p><p><strong>暂存</strong>：使用命令 <code>git add filename</code> 存储此文件的更新，或者使用命令 <code>git add .</code> 存储所有<strong>更新</strong>；</p><p><strong>提交</strong>：当所有<strong>更新</strong>都 add 后，就可以使用命令 <code>git commit -m &quot;update info&quot;</code> <strong>提交</strong>，此时会在 HEAD 基础上产生一个新的版本，并使 HEAD 指向此新版本； </p><p>因此，Git 的基本核心操作，几乎都是 update、add、commit。</p><p>每个<strong>更新</strong>都会可能经历以下几种状态：</p><ul><li><p>还没有此更新：对工作区的文件没有修改；</p><ul><li>git status：nothing to commit, working tree <strong>clean</strong></li></ul></li><li><p>已更新未暂存：对工作区中的文件修改了，但没有使用 <code>git add</code> 命令暂存到暂存区；</p><ul><li>changes <strong>not staged</strong> for commit: </li><li>​                    modified:      filename</li></ul></li><li><p>已更新并暂存：对工作区中的文件修改了，并且使用 <code>git add</code> 命令暂存到了暂存区；</p><ul><li>changes to be <strong>committed</strong>:</li><li>​                     modified:      filename</li></ul></li><li><p>已提交：此更新在暂存区时，使用了 git commit 命令，将此更新提交了。</p></li></ul><h3 id="撤销和回退"><a href="#撤销和回退" class="headerlink" title="撤销和回退"></a>撤销和回退</h3><blockquote><p>详细全面的更新撤销和版本回退的命令参考：<a href="./%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.md#%E6%92%A4%E9%94%80">常用命令 - 撤销</a> !</p></blockquote><p>对于各种状态下的更新的撤销方法是：</p><ul><li>已提交的：<ul><li>对提交过的更新的撤销，就是版本回退！</li><li>使用版本回退命令 <code>git reset --hard id</code> 回退至 id 标识的版本；</li><li>回退后，当前工作区的内容变成 id 标识的版本刚刚被提交后的状态；</li><li>但是，被回退的那些版本并不会被彻底删除，还是保存着的，</li><li>还能使用 <code>git reset --hard id</code> 重新回到那些版本（但要记得其版本 id），</li><li>记不住不用担心，<code>git reflog</code> 这个命令会帮你记住的！</li></ul></li><li>已更新并暂存的：<ul><li>使用命令 <code>git restore --staged filename</code> 将文件 filename 的暂存的更新取消暂存；</li><li>但此文件的内容并不会变，只是更新的状态取消暂存了，变成了已更新未暂存；</li></ul></li><li>已更新未暂存的：<ul><li>使用命令 <code>git restore filename</code> 撤销此文件的新的更新；</li><li>此时文件的内容就和 HEAD 版本一样了！</li><li>注意，<strong>此操作不可逆的</strong>，因为此更新还未被 git 记录为一个版本！</li></ul></li></ul><h3 id="版本切换"><a href="#版本切换" class="headerlink" title="版本切换"></a>版本切换</h3><blockquote><p>切换的是当前分支的当前版本！</p></blockquote><p>若想回退到以前的版本，可以使用命令 <code>git reset --hard id</code> ；</p><p>记住：此命令执行时最好是在刚刚执行提交命令之后，即没有未添加和提交的更新时。</p><p>回退到上一版本：<code>git reset --hard HEAD^</code>；</p><p><code>HEAD</code>：当前最新版本，</p><p><code>HEAD^</code>：上一版本，</p><p><code>HEAD^^</code>：上上一版本，</p><p>回退版本之后，HEAD 指向了上一版本，上一版本就成了此时的最新版本，</p><p>但是，之前的最新版本并不会消失，只要记住其版本 id，还能使用此命令再回到那个版本；</p><p>id 记不住不用担心，<code>git reflog</code> 这个命令会帮你记住的！</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><blockquote><p>详细全面的命令参考：<a href="./%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.md#%E5%88%86%E6%94%AF">常用命令 - 分支</a> !</p></blockquote><p><strong>查看</strong>：使用命令 <code>git branch</code> 查看分支；其中当前所在分支的名字前有星号 * 标识；</p><p><strong>新建分支</strong>：<code>git branch new-branch-name</code> </p><p><strong>切换分支</strong>：<code>git checkout branch-name</code> </p><p><strong>合并某分支到当前分支</strong>：<code>git merge branch-name</code> </p><p><strong>删除分支</strong>：<code>git branch -d branch-name</code> </p><p>注意：</p><ul><li>所有<strong>未提交的更新</strong>在切换分支后还是存在的，所以切换分支之前工作区最好没有任何更新；</li><li>当两个分支是不同的版本时，工作区有更新未 add 或 提交时，是切换不了分支的。</li><li>因此，若有紧急事情需要立即切换到其他分支去处理，那么可以使用命令 <a href="#%E7%B4%A7%E6%80%A5%E4%BB%BB%E5%8A%A1%E6%83%85%E5%86%B5"><code>git stash</code>(见下文)</a> 移出并保存当前工作区内的所有更新！</li></ul><h3 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h3><p><strong>冲突</strong>：当将<strong>某分支</strong>合并到<strong>当前分支</strong>时，可能会产生冲突，冲突是 git 无法自主决定去留的来自两个分支的内容；</p><p>在文件中，冲突内容形式为：</p><ul><li>以 <code>=======</code> 分开，</li><li>上面至 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; branch-name</code> 是当前分支的内容，</li><li>下面至 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-name</code> 是某分支的内容，</li></ul><p><strong>解决冲突</strong>：就是手动决定两个分支的内容的去留；</p><p><strong>提交</strong>：手动解决好所有冲突之后，再提交一次，即将冲突的解决提交为一个新版本。</p><h3 id="紧急任务情况"><a href="#紧急任务情况" class="headerlink" title="紧急任务情况"></a>紧急任务情况</h3><p><strong>情况</strong>：当在某分支工作时，工作只做到了一半，也就是有文件处于以下状态：</p><ul><li>git status : changes not staged for commit</li></ul><p>但是，此时要立即切到其他分支处理一个紧急任务，然而当前工作区的内容还不能 add，更不能提交；</p><p><strong>保存现场</strong>：所以，去处理紧急事件之前，需要对当前工作区未 add 的更新做些处理：</p><ul><li>使用命令 <code>git stash</code> 将当前工作区的未 add 的更新移除工作区并保存起来；</li><li>此时，git status: nothing to commit, working tree clean</li></ul><p>然后，就可切换分支去处理紧急事件了；待紧急事件处理后，切换到之前的工作分支继续之前的工作；</p><ul><li>但此时，git status : nothing to commit, working tree clean</li></ul><p><strong>恢复现场</strong>：使用命令 <code>git stash list</code> 查看隐藏的工作现场，</p><ul><li>使用 <code>git stash apply</code> 将 <code>stash list</code> 中的第一个取出，</li><li>使用 <code>git stash pop</code> 将 <code>stash list</code> 中的第一个取出并从 <code>stash list</code> 中删除，</li><li>使用 <code>git stash drop</code> 将 <code>stash list</code> 中的第一个删除，</li></ul><p>取出第一个放到工作区中，即可继续之前的工作。</p><h2 id="协同工作"><a href="#协同工作" class="headerlink" title="协同工作"></a>协同工作</h2><blockquote><p>使用 Github 这个远程仓库的一个主要作用就是多人在线协作！</p><p>因此，除了本地仓库的管理，还需将工作分享给其他协作者！</p></blockquote><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p><strong>查看</strong>：使用命令 <code>git remote -v</code> 查看所有管理的远程库的信息；</p><ul><li>(fetch) 表示默认拉取的远程仓库</li><li>(push) 表示默认推送的远程仓库</li></ul><p><strong>添加</strong>：使用命令 <code>git remote add name url</code> 将以地址 <code>url</code> 标识的远程仓库添加到本地，并命名为 name；</p><p><strong>删除</strong>：使用命令 <code>git remote remove name</code> 删除名为 name 的远程仓库；</p><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p><strong>查看</strong>：使用命令 <code>git branch -a</code> 查看所有分支；使用命令 <code>git branch -r</code> 查看远程分支；</p><p><strong>获取</strong>：使用命令 <code>git fetch</code> 拉去远程仓库的所有分支的信息；</p><p><strong>关联</strong>：使用命令 <code>git branch -vv</code> 查看本地分支与远程分支关联信息；</p><p><strong>绑定</strong>：使用命令 <code>git branch -u remote/branch</code> 将远程分支 <code>remote/branch</code> 作为当前本地分支的上游；</p><ul><li>绑定上游分支之前，需要获取到远程分支信息；</li><li>绑定之后，在当前本地分支进行 pull、push 等操作时，默认从绑定的远程分支上操作。</li></ul><h3 id="推送拉取"><a href="#推送拉取" class="headerlink" title="推送拉取"></a>推送拉取</h3><p><strong>拉取</strong>：使用命令 <code>git pull remote/branch</code> 将远程分支 <code>remote/branch</code> 拉取并与本地当前分支合并（可能有冲突）；</p><p><strong>获取</strong>：使用命令 <code>git fetch</code> 拉去远程仓库的所有分支的信息，仅仅获取，并未合并；</p><p><strong>推送</strong>：使用命令 <code>git push remote/branch</code> 将本地当前分支推送到远程分支 <code>remote/branch</code> ，并在远程与之合并（此操作由远程仓库管理员操作）；</p><p><strong>默认</strong>：命令 <code>git pull</code> 、<code>git push</code> 在本地分支有绑定的远程分支时，可以默认拉取推送。</p><h3 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h3><p>要能够 push，需要本地保存远程信息，并且将本地分支与远程的分支作链接关系，</p><p>添加远程仓库，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add origin https://xxx/xxx/xxx.git<br></code></pre></td></tr></table></figure><ul><li>一般将远程仓库称为 origin，但可以任意改</li><li>可以添加多个远程仓库</li></ul><p>在 Push 时，关联分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push -u &lt;remote &quot;branch&quot;&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">git push -u origin <span class="hljs-string">&quot;master&quot;</span></span><br></code></pre></td></tr></table></figure><ul><li>当本地当前分支，没有关联远程分支时，且远程没有 “branch” 这个分支时，可以使用此命令，</li><li>远程会新建 master 分支，将本地要推送的分支与之关联，并进行 push，</li></ul><p>直接关联或更改远程分支:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -u &lt;remote/&quot;branch&quot;&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">git beanch -u origin/dev2      <span class="hljs-comment"># 关联当前分支与远程分支</span></span><br></code></pre></td></tr></table></figure><ul><li>关联之前，在本地要先知道远程存在 “branch” 分支，即要先 fetch 它一次，</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git fecth &lt;remote branch&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">git fetch origin dev</span><br></code></pre></td></tr></table></figure><ul><li>fetch 只会获得远程的最新信息，即 FETCH_HEAD ，相当于一个”指针“，这样本地就知道远程有这个分支及其最新的提交id，</li><li>然后，可以对其进行其他操作，比如 设置关联、合并等；</li></ul><h2 id="搭建-Git-服务器"><a href="#搭建-Git-服务器" class="headerlink" title="搭建 Git 服务器"></a>搭建 Git 服务器</h2><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>安装 Git 和 ssh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install git<br>sudo apt-get install ssh<br></code></pre></td></tr></table></figure><h3 id="启动-Git-服务"><a href="#启动-Git-服务" class="headerlink" title="启动 Git 服务"></a>启动 Git 服务</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">service ssh start<br></code></pre></td></tr></table></figure><h3 id="Git-用户配置"><a href="#Git-用户配置" class="headerlink" title="Git 用户配置"></a>Git 用户配置</h3><p>给服务器增加管理 Git 的用户</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo adduser git<br><span class="hljs-comment"># 可以为git用户创建用户组gits</span><br></code></pre></td></tr></table></figure><p>此时，生成了用户 git 的用户文件夹：&#x2F;home&#x2F;git</p><p>创建 ssh 公钥管理文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /home/git<br>sudo <span class="hljs-built_in">mkdir</span> /home/git/.ssh<br>sudo <span class="hljs-built_in">touch</span> /home/git/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p>并修改此文件的权限和所属权</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">chmod</span> 700 /home/git<br>sudo <span class="hljs-built_in">chmod</span> 700 /home/git/.ssh<br>sudo <span class="hljs-built_in">chmod</span> 600 /home/git/authorized_keys<br>sudo <span class="hljs-built_in">chown</span> -R git:git /home/git<br>sudo <span class="hljs-built_in">chown</span> -R git:git /home/git/.ssh<br>sudo <span class="hljs-built_in">chown</span> -R git:git /home/git/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><h3 id="创建仓库路径"><a href="#创建仓库路径" class="headerlink" title="创建仓库路径"></a>创建仓库路径</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">mkdir</span> github <span class="hljs-comment"># 此路径在/home/git中创建</span><br>sudo <span class="hljs-built_in">chown</span> git:git github<br></code></pre></td></tr></table></figure><h3 id="安全处理"><a href="#安全处理" class="headerlink" title="安全处理"></a>安全处理</h3><p>禁止 git 用户登录服务器</p><p>先使用下命令找到 git-shell 的位置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">which</span> git-shell<br><span class="hljs-comment"># 比如 /usr/local/git/bin/git-shell</span><br></code></pre></td></tr></table></figure><p>修改&#x2F;etc&#x2F;passwd中的内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/passwd<br></code></pre></td></tr></table></figure><p>将 <code>git:x:1004:1004:,,,:/home/git:/bin/bash</code> 修改成 <code>git:x:1004:1004:,,,:/home/git:/usr/local/git/bin/git-shell</code>，其中的路径就是刚刚查到的。</p><h3 id="添加-SSH-公钥"><a href="#添加-SSH-公钥" class="headerlink" title="添加 SSH 公钥"></a>添加 SSH 公钥</h3><blockquote><p>使用 root 操作</p></blockquote><p>将本地生成的公钥复制到服务器上的 &#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys文件中。</p><h3 id="新建空白仓库"><a href="#新建空白仓库" class="headerlink" title="新建空白仓库"></a>新建空白仓库</h3><blockquote><p>使用 root 操作，但要设置所属权！</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /home/git/github<br>sudo git init --bare test.git<br>sudo <span class="hljs-built_in">chown</span> -R git:gits test.git <span class="hljs-comment"># 用户:用户组</span><br></code></pre></td></tr></table></figure><p>此 test.git 仓库的地址就是：git@ip:&#x2F;home&#x2F;git&#x2F;github&#x2F;test.git；</p><p>然后，就可以在本地克隆此仓库，并正常使用了。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
